# **Отчет о выполнении Домашнего задания №1**

## Вариант 31

# Условие задачи

Сформировать массив B из элементов массива A в следующем
порядке: сначала заполняем массив В нечётными числами, а затем чётными.

---

# Структура проекта

- [Часть 1](./part1/)
- [Часть 2](./part2/)
- [Тесты](./test/)
- [Результаты тестов](./test_results)

# На 4 балла

### Приведено решение задачи на C

---

Решение представленно в файле:

- [part1/foo.c](./part1/foo.c)

### Компиляция программы на C в ассемблерной программу

---

Программа на C была скомпилированна в ассеблерную программу с импользованием синтаксиса Intel, без использования флагов оптимизации и отладочных опций:

`gcc -masm=intel ./foo.c -S -o ./foo.s`

В ассемблерную программу добавлены комментарии, полностью поясняющие эквивалентное решение на C. Реализацию можно посмотреть в файле:

- [part1/foo.s](./part1/foo.s)

### Оптимизация и модификация ассемблерной программы

---

Программа на C была скомпилированна в ассеблерную программу с импользованием синтаксиса Intel и дополнительных флагов для оптимизации с помощью команды:

```
gcc -masm=intel \
    -fno-asynchronous-unwind-tables \
    -fno-jump-tables \
    -fno-stack-protector \
    -fno-exceptions \
    ./foo.c \
    -S -o ./optimized.s
```

Результат сохранён в файл [optimized.s](./part1/optimized.s)

Затем было проведено ручное редактирование исходного текста ассемблерной программы, в ходе которого убрано лишнее (мета-информация gcc и т.д.)

Результат сохранён в файл [modified.s](./part1/modified.s)

Далее файл modified.s были добавлены комментарии, полностью поясняющие работу ассемблерной программы.

### Компиляция модифицированной ассемблерной программы

---

Оптизированная и откомментированная программа была откомпилирована и скомпонована в исполняемый файл без опций отладки, с помощью команды:

`gcc ./modified.s -o ./modified.o`

### Тестирование

---

Входные данные для тестового покрытие находится в [папке тестов](./test/)

Файлы тестов имеют расширение **.in**

Выходные данные тестового покрытия находятся в [папке результатов тестов](./test_results/).

Результаты тестов каждой программы (C и ассемблерной) сохраняются в подпапку в папке тестов с соотвествующим названию тестируемого файла названием подпапки.

Выходные данные имеют расширение **.out**

Канонические (верные) результаты работы программы находятся в [папке ./test_results/canon](./test_results/canon).

Результаты тестовых прогонов совпали с ожидаемыми входными данными.

---

# На 5 баллов

## Функции с передачей данных:

---

в программе реализованно 3 функции с передачей данных:

```
Input(int n);
Create(int n);
Print(int n);
```

Их реализацию на C можно найти соотвественно в файлах:

- [input.c](./part2/input.c) - функция ввода первого массива
- [create.c](./part2/create.c) - функция создание второго массива
- [print.c](./part2/print.c) - функция вывода второго массива

И основной файл main.c

- [main.c](./part2/main.c) - основной файл

## Локальные переменные

---

В коде функций используются локальные переменные:

В Create:
`int i, j = 0, k = 0;`

В Input и Print:
`int i;`

## Комментарии к ассемблер файлам, описывающие передачу параметров

Все файлы декомпозированной программы скомпилированы в файлы, содержащие ассемблерную программу

- [input.s](./part2/input.s) - ввод первого массива
- [create.s](./part2/create.s) - создание второго массива
- [print.s](./part2/print.s) - вывод второго массива
- [main.s](./part2/main.s) - основной файл

В каждом из файлов добавлены подробные комментарии, полностью поясняющие работу ассемблерной программы и описывающие связь между параметрами языки C и регистрами, стеком

### Компиляция

Была дополнительно произведена компиляция декомпозированной версии программы, с помощью команд

```
gcc -masm=intel \
    -fno-asynchronous-unwind-tables \
    -fno-jump-tables \
    -fno-stack-protector \
    -fno-exceptions \
    ./main.c \
    -S -o ./main.s

gcc -masm=intel \
    -fno-asynchronous-unwind-tables \
    -fno-jump-tables \
    -fno-stack-protector \
    -fno-exceptions \
    ./input.c \
    -S -o ./input.s

    gcc -masm=intel \
    -fno-asynchronous-unwind-tables \
    -fno-jump-tables \
    -fno-stack-protector \
    -fno-exceptions \
    ./create.c \
    -S -o ./create.s

gcc -masm=intel \
    -fno-asynchronous-unwind-tables \
    -fno-jump-tables \
    -fno-stack-protector \
    -fno-exceptions \
    ./print.c \
    -S -o ./print.s
```

Далее, все полученные ассемблерные программы были оптимизированы (убран лишний мусор от компилятора).

Файлы собраны в объектные:

```
gcc ./main.c -c -o ./main.o
gcc ./input.c -c -o ./input.o
gcc ./create.c -c -o ./create.o
gcc ./print.c -c -o ./print.o
```

А затем программа слинкована и собрана в исполняемый файл:

`gcc ./input.o ./create.o ./print.o ./main.o -o result.exe`

# На 6 баллов

## Использование регистров процессора

Была оптимизирована функция create, в ней заменены переменные на стеке, на регистры.

### Изменения в create.s

` DWORD PTR -20[rbp] -> r12d` - переменная для аргумента функции n
` DWORD PTR -8[rbp] -> r13d` - счётчик j
` DWORD PTR -12[rbp] -> r14d` - счётчик k
` DWORD PTR -4[rbp] -> r15d` - счётчик цикла i

Благодаря данной оптимизации уменьшается количество запросов на стек, что уменьшит время работы программы.

Результаты тестов показывают, что данное изменение не повлияло на корректность работы программы.

Part3 скомпилированы, скомпонованы и собраны в исполняемый файл part3.exe

### Тестирование

Результаты тестовых прогонов находятся в [папке результатов тестов](./test_results/part3.exe/).

Сравнение с результатами остальных тестовых прогонов произведено и показывает, что отличий нет. Другие тестовые прогоны можно найти в папке test_results/
